# rotation_invariant_checking.py
import numpy as np
import cv2
from typing import List, Dict, Tuple, Any, Optional
import itertools
import math
import traceback
import time # Import time module


# --- Helper Function for MASK IoU Calculation (Assumes boolean inputs) ---
def calculate_iou(mask1_bool: np.ndarray, mask2_bool: np.ndarray) -> float:
    """Calculates Intersection over Union (IoU) for two boolean masks."""
    intersection = np.sum(mask1_bool & mask2_bool)
    union = np.sum(mask1_bool | mask2_bool)
    return float(intersection / union) if union > 0 else 0.0

# --- Helper Function for Bounding Box IoU (User's Original Version) ---
def calculate_bbox_iou(box1: List[int], box2: List[int]) -> float:
    """
    Calculates IoU for two bounding boxes [x1, y1, x2, y2].
    Uses +1 logic suitable for inclusive pixel coordinates.
    """
    x1_i, y1_i, x2_i, y2_i = box1
    x1_j, y1_j, x2_j, y2_j = box2

    # Determine the coordinates of the intersection rectangle
    x_left = max(x1_i, x1_j)
    y_top = max(y1_i, y1_j)
    x_right = min(x2_i, x2_j)
    y_bottom = min(y2_i, y2_j)

    # If width or height of intersection is negative, no overlap
    if x_right < x_left or y_bottom < y_top:
        return 0.0

    # Calculate intersection area (ensure width/height are non-negative)
    # Add 1 because coordinates are inclusive pixel indices
    intersection_area = (x_right - x_left + 1) * (y_bottom - y_top + 1)

    # Calculate area of both bounding boxes (using +1 for inclusive coords)
    area1 = (x2_i - x1_i + 1) * (y2_i - y1_i + 1)
    area2 = (x2_j - x1_j + 1) * (y2_j - y1_j + 1)

    # Calculate union area
    union_area = float(area1 + area2 - intersection_area)

    # Handle division by zero
    if union_area <= 0:
        return 0.0
    else:
        iou = intersection_area / union_area
        return float(iou)
# --- End Helper Function ---


class RotationInvariantAOIChecker:
    """
    Checks masks based on features and spatial constraints. Includes detailed timing.
    Workflow: Edge->(Optional)MaskIoU->Feature->BBoxNMS->Distance->Containment->RelPos->Count->Overlap
    """

    def __init__(self, config: Dict[str, Any]):
        """
        Initializes the checker with configuration loaded from a dictionary.

        Args:
            config (Dict[str, Any]): The configuration dictionary, typically loaded
                                     from the JSON generated by the learning tool.
                                     Expected keys: "target_objects", "distance_constraints",
                                     "relative_position_constraints", "overlap_rules".
        """
        if not isinstance(config, dict): raise ValueError("Configuration must be a dictionary.")
        print("[Init] Loading configuration...")
        self.config = config
        self.target_objects = config.get("target_objects", {})
        self.distance_constraints = config.get("distance_constraints", {})
        self.overlap_rules = config.get("overlap_rules", [])
        self.relative_position_constraints = config.get("relative_position_constraints", {})

        # --- Configuration Parsing and Validation ---
        # Convert feature ranges from lists to tuples for potential performance benefits
        target_objects_dict = self.target_objects
        if target_objects_dict and isinstance(target_objects_dict, dict):
            for spec in target_objects_dict.values():
                if isinstance(spec, dict) and "feature_ranges" in spec and isinstance(spec["feature_ranges"], dict):
                    for key, value in spec["feature_ranges"].items():
                        if isinstance(value, list) and len(value) == 2:
                            try:
                                spec["feature_ranges"][key] = tuple(map(float, value))
                            except (ValueError, TypeError):
                                print(f"[Warning][Init] Invalid feature range {key}: {value}.")

        # Convert distance constraint ranges to tuples
        if self.distance_constraints and isinstance(self.distance_constraints, dict):
            for constraint in self.distance_constraints.values():
                if isinstance(constraint, dict) and "range" in constraint and isinstance(constraint["range"], list) and len(constraint["range"]) == 2:
                    try:
                        constraint["range"] = tuple(map(float, constraint["range"]))
                    except (ValueError, TypeError):
                        print(f"[Warning][Init] Invalid distance range: {constraint['range']}.")

        # Convert relative position constraint ranges to tuples
        if self.relative_position_constraints and isinstance(self.relative_position_constraints, dict):
            for constraint in self.relative_position_constraints.values():
                valid = True
                if isinstance(constraint, dict):
                    for key in ["dx_range", "dy_range"]:
                        value = constraint.get(key)
                        if isinstance(value, list) and len(value) == 2:
                            try:
                                constraint[key] = tuple(map(float, value))
                            except (ValueError, TypeError):
                                print(f"[Warning][Init] Invalid relative pos range {key}: {value}."); valid = False; break
                        else:
                            print(f"[Warning][Init] Invalid relative pos format {key}: {value}."); valid = False; break
                else:
                    valid = False; print(f"[Warning][Init] Invalid relative pos constraint format: {constraint}")

        # Prepare classification rules list
        self.classification_rules = []
        if target_objects_dict and isinstance(target_objects_dict, dict):
            for obj_type, spec in target_objects_dict.items():
                if isinstance(spec, dict) and "feature_ranges" in spec and "expected_evaluation_count" in spec:
                    feature_ranges = spec.get("feature_ranges", {})
                    expected_eval_count = spec.get("expected_evaluation_count", 0)
                    self.classification_rules.append({'type': obj_type, 'ranges': feature_ranges, 'expected_count': expected_eval_count})
            print(f"[Init] Loaded {len(self.classification_rules)} classification rules.")
        else:
            print("[Warning][Init] 'target_objects' missing or invalid.")

        # Print summary of loaded constraints
        if self.distance_constraints: print(f"[Init] Loaded {len(self.distance_constraints)} distance constraint rule(s).")
        if self.relative_position_constraints: print(f"[Init] Loaded {len(self.relative_position_constraints)} relative position constraint rule(s).")
        if self.overlap_rules: print(f"[Init] Loaded {len(self.overlap_rules)} overlap rule(s).")
        print("[Init] RotationInvariantAOIChecker Initialized.")
        # --- End Configuration Parsing ---

    def extract_features(self, mask: np.ndarray) -> Optional[Dict[str, Any]]:
        """
        Computes geometric and positional features for a single mask.

        Includes: area, aspect ratio, centroid, perimeter, larger/smaller dimensions
                  of the minimum rotated rectangle, angle of the rectangle, vertices
                  of the rectangle, and the axis-aligned bounding box.

        Args:
            mask (np.ndarray): A 2D NumPy array (uint8 or bool) representing the mask.

        Returns:
            Optional[Dict[str, Any]]: A dictionary containing the extracted features,
                                      or None if the mask is invalid or empty.
        """
        if not isinstance(mask, np.ndarray) or mask.ndim != 2: return None
        # Ensure mask is uint8 for OpenCV functions
        if mask.dtype != np.uint8:
            mask_uint8 = mask.astype(np.uint8)
        else:
            mask_uint8 = mask

        area = float(np.sum(mask_uint8 > 0))
        if area == 0: return None # Skip empty masks

        # Get pixel coordinates
        y_indices, x_indices = np.where(mask_uint8 > 0)
        if len(x_indices) == 0 or len(y_indices) == 0: return None # Should not happen if area > 0

        # --- Axis-aligned Bounding Box (Inclusive Pixel Coords) ---
        x1, y1 = int(np.min(x_indices)), int(np.min(y_indices))
        x2, y2 = int(np.max(x_indices)), int(np.max(y_indices))
        bbox = [x1, y1, x2, y2] # Format: [x_min, y_min, x_max, y_max]

        # --- Centroid ---
        # Using mean of coordinates is often more robust for non-convex shapes than moments
        centroid_x, centroid_y = float(np.mean(x_indices)), float(np.mean(y_indices))

        # --- Minimum Area Rotated Rectangle Features ---
        points = np.column_stack((x_indices, y_indices)).astype(np.float32)
        angle = 0.0
        min_rect_vertices = None
        raw_width, raw_height = 0.0, 0.0
        try:
            # Calculate the minimum area rectangle enclosing the mask points
            rect = cv2.minAreaRect(points)
            # rect format: ((center_x, center_y), (width, height), angle)
            raw_width, raw_height = rect[1] # Width and height of the rectangle
            angle = float(rect[2]) # Angle (-90 to 0 degrees)
            # Get the 4 vertices of the rotated rectangle
            box = cv2.boxPoints(rect)
            min_rect_vertices = box # Keep as float initially if needed, convert later
        except cv2.error:
             print("[Warning][Features] cv2.minAreaRect failed.") # Handle potential OpenCV errors

        # Ensure width/height are non-negative
        raw_width = max(0.0, raw_width)
        raw_height = max(0.0, raw_height)

        larger_dim = float(max(raw_width, raw_height))
        smaller_dim = float(min(raw_width, raw_height))
        aspect_ratio = smaller_dim / larger_dim if larger_dim > 0 else 0.0

        # --- Perimeter (from contour) ---
        perimeter = 0.0
        try:
            # Find contours (external only)
            contours, _ = cv2.findContours(mask_uint8, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            if contours:
                # Use the largest contour found (usually the main object)
                largest_contour = max(contours, key=cv2.contourArea)
                perimeter = float(cv2.arcLength(largest_contour, closed=True))
        except cv2.error:
            pass # Ignore contour errors

        # Return dictionary of all features
        return {
            "area": area,
            "aspect_ratio": aspect_ratio,
            "centroid_x": centroid_x,
            "centroid_y": centroid_y,
            "perimeter": perimeter,
            "larger_dim": larger_dim,
            "smaller_dim": smaller_dim,
            "angle": angle, # Angle from minAreaRect
            "min_rect_vertices": min_rect_vertices, # Vertices from minAreaRect
            "bbox": bbox # Axis-aligned bounding box [x1, y1, x2, y2]
        }

    def _filter_edge_masks(self, masks: List[np.ndarray], filter_shape: Tuple[int, int], edge_threshold: int) -> List[np.ndarray]:
        """
        Filters out masks whose bounding boxes are too close to the image edges.

        Args:
            masks (List[np.ndarray]): List of input masks.
            filter_shape (Tuple[int, int]): The shape (height, width) of the image.
            edge_threshold (int): Minimum pixel distance allowed from any edge.

        Returns:
            List[np.ndarray]: List of masks that are not too close to the edges.
        """
        filter_height, filter_width = filter_shape
        filtered_masks = []
        for i, mask in enumerate(masks):
            if not isinstance(mask, np.ndarray) or mask.ndim != 2: continue # Skip invalid masks
            y_indices, x_indices = np.where(mask > 0)
            if len(y_indices) == 0: continue # Skip empty masks

            # Get bounding box
            x1, x2 = np.min(x_indices), np.max(x_indices)
            y1, y2 = np.min(y_indices), np.max(y_indices)

            # Check proximity to edges
            is_near_edge = (x1 < edge_threshold or
                            x2 >= filter_width - edge_threshold or
                            y1 < edge_threshold or
                            y2 >= filter_height - edge_threshold)

            if not is_near_edge:
                filtered_masks.append(mask) # Keep mask if not near edge

        return filtered_masks

    def test_masks(self, masks: List[np.ndarray], filter_shape: Tuple[int, int], max_masks_to_show: int = None,
                   edge_threshold: int = 5, sort_by_area: bool = True) -> List[Dict[str, Any]]:
        """
        Processes masks for testing/visualization purposes.
        Performs edge filtering, extracts features, and formats results.
        Does NOT perform classification or evaluation against the config.

        Args:
            masks (List[np.ndarray]): List of input masks.
            filter_shape (Tuple[int, int]): Image shape (height, width).
            max_masks_to_show (Optional[int]): Maximum number of masks to return (sorted by area if applicable).
            edge_threshold (int): Threshold for edge filtering.
            sort_by_area (bool): If True, sorts the results by mask area (descending).

        Returns:
            List[Dict[str, Any]]: List of dictionaries, each containing 'mask', 'features',
                                  'min_rect_vertices' (as list), and 'labels' for visualization.
        """
        # 1. Filter masks near edges
        valid_masks = self._filter_edge_masks(masks, filter_shape, edge_threshold)
        if not valid_masks: return []

        # 2. Extract features for remaining masks
        mask_features_list = []
        for mask in valid_masks:
            features = self.extract_features(mask)
            if features:
                mask_features_list.append({"mask": mask, "features": features})
        if not mask_features_list: return []

        # 3. Sort by area if requested
        if sort_by_area:
            mask_features_list.sort(key=lambda x: x["features"]["area"], reverse=True)

        # 4. Limit number of masks if requested
        if max_masks_to_show is not None and len(mask_features_list) > max_masks_to_show:
            mask_features_list = mask_features_list[:max_masks_to_show]

        # 5. Format results for visualization
        results = []
        for item in mask_features_list:
            mask = item["mask"]
            features = item["features"]
            # Get vertices and convert to list of lists for easier handling/JSON
            min_rect_vertices_np = features.get("min_rect_vertices")
            min_rect_vertices_list = min_rect_vertices_np.tolist() if isinstance(min_rect_vertices_np, np.ndarray) else [[0,0]]*4 # Fallback

            # Prepare basic labels for visualization
            labels = [
                f"Area: {features.get('area', 0):.0f}",
                f"AR: {features.get('aspect_ratio', 0):.2f}",
                f"Angle: {features.get('angle', 0):.1f}"
            ]
            results.append({
                "mask": mask,
                "features": features,
                "min_rect_vertices": min_rect_vertices_list, # Use the list version
                "labels": labels
            })
        return results

    def classify_masks(self,
                       masks: List[np.ndarray],
                       filter_shape: Tuple[int, int],
                       edge_threshold: int,
                       # *** NEW PARAMETER ***
                       enable_mask_iou_filter: bool = True, # Default to enabled
                       iou_threshold: float = 0.9, # Mask IoU threshold
                       enable_relative_position_check: bool = True,
                       relative_position_pairs_to_check: Optional[List[str]] = None,
                       enable_containment_check: bool = True,
                       containment_reference_type: str = "bezel",
                       containment_target_type: str = "stamped_mark",
                       enable_bbox_nms: bool = True, # BBox NMS enable flag
                       bbox_nms_iou_threshold: float = 0.5, # BBox NMS IoU threshold
                       bbox_nms_target_types: Optional[List[str]] = None # Types for BBox NMS
                       ) -> Dict[str, List[Dict]]:
        """
        Performs the full sequence of classification and filtering steps on input masks.

        Workflow Steps:
        1. Edge Filter: Removes masks too close to image borders.
        2. Mask IoU Filter: (Optional) Removes highly overlapping masks (pixel-based).
        3. Feature Classification: Assigns a tentative type based on feature ranges.
        4. BBox NMS Filter: (If enabled) Removes overlapping bounding boxes for specified types.
        5. Distance Filter: Checks pairwise distances against constraints.
        6. Containment Filter: (If enabled) Checks if target centroid is within ref bbox X or Y range.
        7. Relative Position Filter: (If enabled) Checks relative positions against constraints.

        Args:
            (See evaluate method for descriptions of most args)
            enable_mask_iou_filter (bool): If True, applies the Mask IoU filter.
            iou_threshold (float): IoU threshold for removing overlapping *masks*.
            bbox_nms_iou_threshold (float): IoU threshold for removing overlapping *bounding boxes*.

        Returns:
            Dict[str, List[Dict]]: Dictionary mapping object types to lists of mask info
                                   dictionaries that passed *all* filtering steps.
        """
        stage_start_time = time.time()
        print("[Checker][classify_masks] Starting integrated classification...")
        # Default target types for BBox NMS if not provided
        if bbox_nms_target_types is None:
            bbox_nms_target_types = ["stamped_mark"] # Default target

        # --- 1. Edge Filtering ---
        t0 = time.time()
        edge_filtered_masks = self._filter_edge_masks(masks, filter_shape, edge_threshold)
        t1 = time.time()
        print(f"[TIME] Edge Filter: {t1 - t0:.4f}s")
        if not edge_filtered_masks:
            print("[Checker][classify_masks] No masks after edge filtering.")
            # Return empty structure matching expected output format
            return {r['type']: [] for r in self.classification_rules} if self.classification_rules else {}
        print(f"[Checker][classify_masks] Edge filtering complete ({len(edge_filtered_masks)} masks remain).")
        # --- End Edge Filtering ---

        # --- 2. Mask IoU Filtering (Pixel-based) ---
        t0 = time.time()
        iou_filtered_masks = [] # Initialize
        if enable_mask_iou_filter:
            print(f"[Checker][classify_masks] Applying Mask IoU filter (Threshold: {iou_threshold:.2f})...")
            num_initial_masks_iou = len(edge_filtered_masks)
            if num_initial_masks_iou <= 1:
                # No need to compare if 0 or 1 mask left
                iou_filtered_masks = edge_filtered_masks
            else:
                # Calculate areas and store indices of non-empty masks
                mask_areas = []
                valid_indices_for_iou = []
                for idx, m in enumerate(edge_filtered_masks):
                    area = np.sum(m.astype(bool))
                    if area > 0:
                        mask_areas.append(area)
                        valid_indices_for_iou.append(idx)

                if len(valid_indices_for_iou) <= 1:
                    # If only 0 or 1 valid mask after checking area
                    iou_filtered_masks = [edge_filtered_masks[i] for i in valid_indices_for_iou]
                else:
                    num_valid_masks = len(valid_indices_for_iou)
                    to_remove_original_indices = set()
                    # Get only the valid masks for comparison
                    valid_masks_for_compare = [edge_filtered_masks[i] for i in valid_indices_for_iou]

                    # Compare each pair of valid masks
                    for i_valid in range(num_valid_masks):
                        original_idx_i = valid_indices_for_iou[i_valid]
                        if original_idx_i in to_remove_original_indices: continue # Skip if already marked for removal

                        for j_valid in range(i_valid + 1, num_valid_masks):
                            original_idx_j = valid_indices_for_iou[j_valid]
                            if original_idx_j in to_remove_original_indices: continue # Skip if already marked

                            mask_i = valid_masks_for_compare[i_valid]
                            mask_j = valid_masks_for_compare[j_valid]
                            # Calculate pixel IoU
                            iou = calculate_iou(mask_i.astype(bool), mask_j.astype(bool))

                            if iou > iou_threshold:
                                # If overlap is high, remove the smaller mask
                                if mask_areas[i_valid] >= mask_areas[j_valid]:
                                    to_remove_original_indices.add(original_idx_j)
                                else:
                                    to_remove_original_indices.add(original_idx_i)
                                    break # Mask i is removed, no need to compare it further

                    # Create the final list keeping only masks not marked for removal
                    iou_filtered_masks = [edge_filtered_masks[i] for i in valid_indices_for_iou if i not in to_remove_original_indices]

            num_removed_iou = num_initial_masks_iou - len(iou_filtered_masks)
            print(f"[Checker][classify_masks] Mask IoU filtering complete ({num_removed_iou} removed, {len(iou_filtered_masks)} remain).")
        else:
            # If filter is disabled, just pass the results from the previous step
            print("[Checker][classify_masks] Mask IoU filter explicitly disabled. Skipping.")
            iou_filtered_masks = edge_filtered_masks # Pass edge filter results directly

        t1 = time.time()
        print(f"[TIME] Mask IoU Filter: {t1 - t0:.4f}s") # Time includes check + potential skip
        if not iou_filtered_masks:
            print("[Checker][classify_masks] No masks after Mask IoU filtering step.")
            return {r['type']: [] for r in self.classification_rules} if self.classification_rules else {}
        # --- End Mask IoU Filtering ---

        # --- 3. Initial Feature Classification ---
        t0 = time.time()
        print("[Checker][classify_masks] Performing initial feature classification...")
        if not self.classification_rules: print("[Error][classify_masks] No classification rules defined."); return {}

        # Dictionary to hold masks tentatively classified by type
        classified_by_features: Dict[str, List[Dict]] = {rule['type']: [] for rule in self.classification_rules}
        # List to hold all masks that passed feature classification (regardless of type)
        feature_classified_list: List[Dict] = []
        unclassified_count = 0

        for mask in iou_filtered_masks: # Use output from previous step
            features = self.extract_features(mask) # Extract features (includes bbox, angle etc.)
            if not features: continue # Skip if feature extraction failed

            classified_flag = False
            for rule in self.classification_rules:
                obj_type = rule['type']
                ranges = rule['ranges'] # Feature ranges from config
                match = True
                if not isinstance(ranges, dict): # Basic validation
                    match = False
                else:
                    # Check if all feature values fall within the defined ranges
                    for feature_key, range_tuple in ranges.items():
                        # Skip non-geometric features if present in ranges (shouldn't be)
                        if feature_key in ['angle', 'min_rect_vertices', 'bbox'] and feature_key not in ranges: continue
                        if not isinstance(range_tuple, (tuple, list)) or len(range_tuple) != 2: match = False; break # Invalid range format
                        min_val, max_val = range_tuple
                        feature_value = features.get(feature_key)
                        # Check if feature exists and is within range
                        if feature_value is None or not (min_val <= feature_value <= max_val):
                            match = False; break
                if match:
                    # If all features match, classify and store
                    mask_info = {"features": features, "mask": mask, "type": obj_type}
                    classified_by_features[obj_type].append(mask_info)
                    feature_classified_list.append(mask_info) # Add to the flat list too
                    classified_flag = True
                    break # Stop checking rules once classified
            if not classified_flag:
                unclassified_count += 1

        num_feature_classified = len(feature_classified_list)
        t1 = time.time()
        print(f"[Checker][classify_masks] Feature classification done. Classified: { {k: len(v) for k, v in classified_by_features.items()} }, Unclassified: {unclassified_count}")
        print(f"[TIME] Feature Classification: {t1 - t0:.4f}s")
        if num_feature_classified == 0:
            print("[Checker][classify_masks] No masks passed feature classification.")
            return classified_by_features # Return empty dict structure
        # --- End Feature Classification ---

        # --- 4. BBox NMS Filter (Bounding Box based) ---
        t0 = time.time()
        # Dictionary to hold masks after BBox NMS
        passed_bbox_nms_filter: Dict[str, List[Dict]] = {}
        # Flat list of masks after BBox NMS
        feature_passed_bbox_nms_list: List[Dict] = []
        objects_removed_bbox_nms = 0

        if not enable_bbox_nms:
            print("[Checker][classify_masks] BBox NMS explicitly disabled. Skipping filter.")
            passed_bbox_nms_filter = classified_by_features # Pass through results
            feature_passed_bbox_nms_list = feature_classified_list
        else:
            print(f"[Checker][classify_masks] Applying BBox NMS filter (IoU Threshold: {bbox_nms_iou_threshold:.2f}, Targets: {bbox_nms_target_types})...")
            # Apply NMS per object type
            for obj_type, masks_info_list in classified_by_features.items():
                if obj_type not in bbox_nms_target_types:
                    # If type is not targeted, keep all masks
                    passed_bbox_nms_filter[obj_type] = masks_info_list
                    feature_passed_bbox_nms_list.extend(masks_info_list)
                else:
                    # Apply BBox NMS for this target type
                    if len(masks_info_list) <= 1:
                        # No NMS needed for 0 or 1 mask
                        if masks_info_list:
                            passed_bbox_nms_filter[obj_type] = masks_info_list; feature_passed_bbox_nms_list.extend(masks_info_list)
                        else:
                            passed_bbox_nms_filter[obj_type] = [] # Ensure key exists
                        continue

                    # Sort by area (or confidence score if available) - using area here
                    masks_info_list.sort(key=lambda info: info.get("features", {}).get("area", 0), reverse=True)

                    kept_indices = []
                    suppressed_indices = [False] * len(masks_info_list)

                    for i in range(len(masks_info_list)):
                        if suppressed_indices[i]: continue # Skip if already suppressed

                        kept_indices.append(i) # Keep this mask
                        bbox_i = masks_info_list[i].get("features", {}).get("bbox")
                        if not bbox_i: continue # Should have bbox, but check anyway

                        # Compare with subsequent masks
                        for j in range(i + 1, len(masks_info_list)):
                            if suppressed_indices[j]: continue

                            bbox_j = masks_info_list[j].get("features", {}).get("bbox")
                            if not bbox_j: continue

                            # *** Use the correct calculate_bbox_iou ***
                            iou = calculate_bbox_iou(bbox_i, bbox_j)

                            if iou > bbox_nms_iou_threshold:
                                suppressed_indices[j] = True # Suppress overlapping mask j
                                objects_removed_bbox_nms += 1

                    # Store the kept masks for this type
                    kept_masks = [masks_info_list[k] for k in kept_indices]
                    passed_bbox_nms_filter[obj_type] = kept_masks
                    feature_passed_bbox_nms_list.extend(kept_masks) # Add to flat list

            print(f"[Checker][classify_masks] BBox NMS filter applied. {objects_removed_bbox_nms} removed.")
        t1 = time.time()
        print(f"[TIME] BBox NMS Filter: {t1 - t0:.4f}s")
        if not feature_passed_bbox_nms_list: # Check if any masks remain overall
             print("[Checker][classify_masks] No masks remaining after BBox NMS filter.")
             return passed_bbox_nms_filter # Return potentially empty dict
        # --- END BBox NMS Filter ---

        # --- 5. Strict Distance Filtering ---
        # Operates on the results of the previous filter (BBox NMS or Feature Classification)
        t0 = time.time()
        print("[Checker][classify_masks] Applying strict distance constraint filter...")
        if not self.distance_constraints:
            print("[Checker][classify_masks] No distance constraints. Skipping distance filter.")
            passed_distance_filter = passed_bbox_nms_filter # Pass through NMS results
            feature_passed_distance_list = feature_passed_bbox_nms_list
        elif not feature_passed_bbox_nms_list: # Check if list is empty
            print("[Checker][classify_masks] No masks remaining after previous filter for distance check.")
            passed_distance_filter = passed_bbox_nms_filter # Pass through NMS results (empty)
            feature_passed_distance_list = feature_passed_bbox_nms_list
        else:
            # Dictionary to hold masks passing distance filter
            passed_distance_filter: Dict[str, List[Dict]] = {rule['type']: [] for rule in self.classification_rules}
            # Flat list of masks passing distance filter
            feature_passed_distance_list: List[Dict] = []
            objects_failed_distance_count = 0
            first_distance_failure_reason = "All objects satisfy applicable distance constraints" # Default

            # Check each object that passed the previous filter
            for obj1_info in feature_passed_bbox_nms_list:
                obj1_type = obj1_info['type']
                obj1_features = obj1_info.get("features", {})
                obj1_passes_all_constraints = True # Assume passes initially
                relevant_constraints = {} # Constraints applicable to this object type
                constraint_check_possible = True

                # Find all distance constraints involving this object type
                for pair_key, constraint_data in self.distance_constraints.items():
                    obj_types_in_pair = pair_key.split('-')
                    if obj1_type in obj_types_in_pair:
                        dist_range = constraint_data.get("range")
                        # Validate range format
                        if not isinstance(dist_range, (tuple, list)) or len(dist_range) != 2:
                            obj1_passes_all_constraints = False
                            failure_reason = f"Dist_NG: Invalid range format '{pair_key}'"
                            if objects_failed_distance_count == 0: first_distance_failure_reason = failure_reason
                            constraint_check_possible = False; break # Stop checking constraints for this obj
                        relevant_constraints[pair_key] = {'data': constraint_data, 'satisfied': False}

                if not constraint_check_possible: objects_failed_distance_count += 1; continue # Skip to next object

                # If there are relevant constraints, check them
                if relevant_constraints:
                    for pair_key, status_info in relevant_constraints.items():
                        if not obj1_passes_all_constraints: break # Stop if already failed

                        constraint_data = status_info['data']
                        min_dist, max_dist = constraint_data["range"]
                        obj_types_in_pair = pair_key.split('-')
                        # Find the *other* object type in the pair
                        obj2_type = next(t for t in obj_types_in_pair if t != obj1_type)
                        # Get the list of potential partners (those that passed previous filters)
                        obj2_list = passed_bbox_nms_filter.get(obj2_type, [])

                        if not obj2_list:
                            # If no potential partners exist, this constraint cannot be satisfied
                            obj1_passes_all_constraints = False
                            failure_reason = f"Dist_NG: {obj1_type} failed '{pair_key}' - no post-NMS '{obj2_type}' found."
                            if objects_failed_distance_count == 0: first_distance_failure_reason = failure_reason
                            break # Stop checking constraints for this obj

                        # Check if *at least one* partner satisfies the distance constraint
                        found_satisfying_pair = False
                        for obj2_info in obj2_list:
                            if obj1_info is obj2_info: continue # Skip self-comparison

                            f1 = obj1_info.get("features"); f2 = obj2_info.get("features")
                            if not f1 or not f2: continue # Skip if features missing

                            c1x, c1y = f1.get("centroid_x"), f1.get("centroid_y")
                            c2x, c2y = f2.get("centroid_x"), f2.get("centroid_y")

                            if None not in [c1x, c1y, c2x, c2y]:
                                try:
                                    dist = math.sqrt((c2x - c1x)**2 + (c2y - c1y)**2)
                                    if min_dist <= dist <= max_dist:
                                        status_info['satisfied'] = True # Mark constraint as satisfied
                                        found_satisfying_pair = True
                                        break # Found a partner, no need to check others for this constraint
                                except Exception:
                                    obj1_passes_all_constraints = False
                                    failure_reason = f"Dist_NG: Error calc dist '{pair_key}'"
                                    if objects_failed_distance_count == 0: first_distance_failure_reason = failure_reason
                                    break # Stop checking constraints

                        if not obj1_passes_all_constraints: break # Exit inner loop if error occurred

                        if not found_satisfying_pair:
                            # If no partner satisfied this constraint, the object fails
                            obj1_passes_all_constraints = False
                            failure_reason = f"Dist_NG: {obj1_type} failed '{pair_key}' - no partner in range."
                            if objects_failed_distance_count == 0: first_distance_failure_reason = failure_reason
                            break # Stop checking constraints for this object

                # Add object to passed list if it satisfied all applicable constraints
                if obj1_passes_all_constraints:
                    passed_distance_filter[obj1_type].append(obj1_info)
                    feature_passed_distance_list.append(obj1_info)
                else:
                    objects_failed_distance_count += 1

            num_passed_distance = len(feature_passed_distance_list)
            print(f"[Checker][classify_masks] Distance filter applied. {objects_failed_distance_count} removed, {num_passed_distance} remain.")
            if num_passed_distance == 0 and len(feature_passed_bbox_nms_list) > 0: # Check if any masks existed before filter
                print("[Checker][classify_masks] No masks passed distance filter.")
                if objects_failed_distance_count > 0: print(f"  Reason: {first_distance_failure_reason}")
                # Return empty structure
                return passed_distance_filter
        t1 = time.time()
        print(f"[TIME] Distance Filter: {t1 - t0:.4f}s")
        # --- End Distance Filtering ---

        # --- 6. Centroid Containment Filter ---
        # Checks if the centroid of the target type falls within the X OR Y range
        # of the axis-aligned bounding box of the reference type.
        t0 = time.time()
        passed_containment_filter: Dict[str, List[Dict]] = {rule['type']: [] for rule in self.classification_rules}
        feature_passed_containment_list: List[Dict] = []
        objects_failed_containment_count = 0

        if not enable_containment_check:
            print("[Checker][classify_masks] Centroid containment check explicitly disabled. Skipping filter.")
            passed_containment_filter = passed_distance_filter # Pass through results
            feature_passed_containment_list = feature_passed_distance_list
        elif not feature_passed_distance_list: # Check if list is empty
            print("[Checker][classify_masks] No masks remaining after distance filter for containment check.")
            passed_containment_filter = passed_distance_filter # Pass through empty results
            feature_passed_containment_list = feature_passed_distance_list
        else:
            print(f"[Checker][classify_masks] Applying centroid containment filter (Target: '{containment_target_type}' inside '{containment_reference_type}' BBox X OR Y range)...")

            # Find the reference object(s) - expects exactly one
            reference_objects = passed_distance_filter.get(containment_reference_type, [])
            reference_bbox = None
            if len(reference_objects) == 1:
                ref_features = reference_objects[0].get("features", {})
                reference_bbox = ref_features.get("bbox") # Get [x1, y1, x2, y2]
                # Validate bbox format
                if not isinstance(reference_bbox, list) or len(reference_bbox) != 4:
                    print(f"[Warning][Containment] Invalid bbox for reference '{containment_reference_type}'. Cannot perform check."); reference_bbox = None
            elif len(reference_objects) == 0:
                 print(f"[Warning][Containment] Reference '{containment_reference_type}' not found after previous filters. Cannot perform check.")
            else: # More than one reference object found
                 print(f"[Warning][Containment] Multiple ({len(reference_objects)}) references '{containment_reference_type}' found. Cannot perform check.")

            # Check each object that passed the distance filter
            for obj_info in feature_passed_distance_list:
                obj_type = obj_info['type']
                obj_features = obj_info.get("features", {})

                # Only apply the check if it's the target type AND a valid reference exists
                if obj_type == containment_target_type and reference_bbox is not None:
                    target_cx = obj_features.get("centroid_x")
                    target_cy = obj_features.get("centroid_y")

                    if target_cx is not None and target_cy is not None:
                        ref_x1, ref_y1, ref_x2, ref_y2 = reference_bbox
                        # Check if centroid is within X range OR Y range
                        is_within_x = (ref_x1 <= target_cx <= ref_x2)
                        is_within_y = (ref_y1 <= target_cy <= ref_y2)

                        if is_within_x or is_within_y:
                            # Keep the object if its centroid is within X or Y range
                            passed_containment_filter[obj_type].append(obj_info)
                            feature_passed_containment_list.append(obj_info)
                        else:
                            # Object failed containment check
                            objects_failed_containment_count += 1
                            # print(f"[Info][Containment] Target '{obj_type}' centroid ({target_cx:.1f},{target_cy:.1f}) outside BOTH X&Y of ref BBox [{ref_x1},{ref_y1},{ref_x2},{ref_y2}]. FAILED.") # More verbose log
                    else:
                        # Should not happen if feature extraction worked, but handle defensively
                        print(f"[Warning][Containment] Missing centroid for target '{obj_type}'. Passing filter.");
                        passed_containment_filter[obj_type].append(obj_info); feature_passed_containment_list.append(obj_info)
                else:
                    # Keep all objects that are not the target type, or if no valid reference exists
                    passed_containment_filter[obj_type].append(obj_info)
                    feature_passed_containment_list.append(obj_info)

            num_passed_containment = len(feature_passed_containment_list)
            print(f"[Checker][classify_masks] BBox OR Containment filter applied. {objects_failed_containment_count} removed, {num_passed_containment} remain.")
            if num_passed_containment == 0 and len(feature_passed_distance_list) > 0: # Check if any masks existed before filter
                print("[Checker][classify_masks] No masks passed BBox OR containment filter.")
                # Return empty structure
                # return passed_containment_filter # Don't return early, let RelPos filter run on empty list if needed
        t1 = time.time()
        print(f"[TIME] Containment Filter: {t1 - t0:.4f}s")
        # --- END Centroid Containment Filter ---

        # --- 7. Relative Position Filtering ---
        # Operates on the results of the containment filter
        t0 = time.time()
        if not enable_relative_position_check:
            print("[Checker][classify_masks] Relative position check explicitly disabled. Skipping filter.")
            final_classification = passed_containment_filter # Pass through results
        elif not self.relative_position_constraints:
            print("[Checker][classify_masks] No relative position constraints defined. Skipping filter.")
            final_classification = passed_containment_filter # Pass through results
        elif not feature_passed_containment_list: # Check if list is empty
            print("[Checker][classify_masks] No masks remaining after containment filter for relative position check.")
            final_classification = passed_containment_filter # Pass through empty results
        else:
            print("[Checker][classify_masks] Applying relative position constraint filter...")

            # Determine which pairs to check based on input parameter
            check_pairs_set = None
            if relative_position_pairs_to_check is not None:
                # Create set of sorted pair keys (e.g., "bezel-copper_mark")
                check_pairs_set = set("-".join(sorted(p.split('-'))) for p in relative_position_pairs_to_check)
                print(f"  - Only checking pairs: {check_pairs_set}")

            # Dictionary to hold final results after relative position filtering
            final_classification: Dict[str, List[Dict]] = {rule['type']: [] for rule in self.classification_rules}
            objects_failed_relpos_count = 0
            first_relpos_failure_reason = "All objects satisfy applicable relative position constraints" # Default

            # Check each object that passed the containment filter
            for obj1_info in feature_passed_containment_list:
                obj1_type = obj1_info['type']
                obj1_features = obj1_info.get("features", {})
                obj1_passes_all_relpos = True # Assume passes initially
                relevant_relpos_constraints = {} # Constraints applicable to this object
                constraint_check_possible = True

                # Find all relative position constraints involving this object type
                # AND filter by the pairs specified in relative_position_pairs_to_check (if provided)
                for pair_key, constraint_data in self.relative_position_constraints.items():
                    obj_types_in_pair = pair_key.split('-')
                    if obj1_type in obj_types_in_pair:
                        # Check if this specific pair should be checked based on input
                        sorted_pair_key = "-".join(sorted(obj_types_in_pair))
                        if check_pairs_set is not None and sorted_pair_key not in check_pairs_set:
                            continue # Skip this constraint if not in the specified list

                        # Validate constraint format
                        dx_range = constraint_data.get("dx_range")
                        dy_range = constraint_data.get("dy_range")
                        if not isinstance(dx_range, tuple) or not isinstance(dy_range, tuple):
                            obj1_passes_all_relpos = False
                            failure_reason = f"RelPos_NG: Invalid range format '{pair_key}'"
                            if objects_failed_relpos_count == 0: first_relpos_failure_reason = failure_reason
                            constraint_check_possible = False; break # Stop checking constraints for this obj
                        relevant_relpos_constraints[pair_key] = {'data': constraint_data, 'satisfied': False}

                if not constraint_check_possible: objects_failed_relpos_count += 1; continue # Skip to next object

                # If there are relevant constraints to check for this object
                if relevant_relpos_constraints:
                    # Get reference object's angle and centroid
                    obj1_angle_deg = obj1_features.get("angle")
                    obj1_cx = obj1_features.get("centroid_x")
                    obj1_cy = obj1_features.get("centroid_y")

                    # Check if necessary features are present
                    if obj1_angle_deg is None or obj1_cx is None or obj1_cy is None:
                        obj1_passes_all_relpos = False
                        failure_reason = f"RelPos_NG: Missing angle/centroid for {obj1_type}"
                        if objects_failed_relpos_count == 0: first_relpos_failure_reason = failure_reason
                    else:
                        # Pre-calculate rotation components (rotate by negative angle)
                        obj1_angle_rad = math.radians(obj1_angle_deg)
                        cos_a = math.cos(-obj1_angle_rad) # Cosine of negative angle
                        sin_a = math.sin(-obj1_angle_rad) # Sine of negative angle

                        # Check each applicable constraint
                        for pair_key, status_info in relevant_relpos_constraints.items():
                            if not obj1_passes_all_relpos: break # Stop if already failed

                            constraint_data = status_info['data']
                            min_dx, max_dx = constraint_data["dx_range"]
                            min_dy, max_dy = constraint_data["dy_range"]
                            obj_types_in_pair = pair_key.split('-')

                            # Determine the type of the partner object
                            if obj_types_in_pair[0] == obj_types_in_pair[1]: # e.g., copper_mark-copper_mark
                                obj2_type = obj1_type
                            else: # Find the other type in the pair
                                other_types = [t for t in obj_types_in_pair if t != obj1_type]
                                if not other_types: # Should not happen with valid keys
                                    obj1_passes_all_relpos = False
                                    failure_reason = f"RelPos_NG: Invalid pair key '{pair_key}'"
                                    if objects_failed_relpos_count == 0: first_relpos_failure_reason = failure_reason
                                    break
                                obj2_type = other_types[0]

                            # Get potential partners (those that passed previous filters)
                            obj2_list = passed_containment_filter.get(obj2_type, [])

                            if not obj2_list:
                                # If no potential partners exist, this constraint cannot be satisfied
                                obj1_passes_all_relpos = False
                                failure_reason = f"RelPos_NG: {obj1_type} failed '{pair_key}' - no post-containment '{obj2_type}' found."
                                if objects_failed_relpos_count == 0: first_relpos_failure_reason = failure_reason
                                break # Stop checking constraints for this obj

                            # Check if *at least one* partner satisfies the relative position constraint
                            found_satisfying_pair = False
                            for obj2_info in obj2_list:
                                if obj1_info is obj2_info: continue # Skip self-comparison

                                f2 = obj2_info.get("features")
                                if not f2: continue # Skip if partner features missing

                                obj2_cx = f2.get("centroid_x")
                                obj2_cy = f2.get("centroid_y")

                                if obj2_cx is not None and obj2_cy is not None:
                                    # Calculate original vector
                                    dx = obj2_cx - obj1_cx
                                    dy = obj2_cy - obj1_cy
                                    # Rotate vector by -angle of obj1 to get relative coordinates
                                    dx_rel = dx * cos_a - dy * sin_a # dx'
                                    dy_rel = dx * sin_a + dy * cos_a # dy'

                                    # Check if relative coordinates are within defined ranges
                                    if (min_dx <= dx_rel <= max_dx) and (min_dy <= dy_rel <= max_dy):
                                        status_info['satisfied'] = True # Mark constraint satisfied
                                        found_satisfying_pair = True
                                        break # Found a partner, no need to check others for this constraint
                                else:
                                    print(f"[Warning][RelPos] Missing centroid for partner {obj2_type}.")

                            if not found_satisfying_pair:
                                # If no partner satisfied this constraint, the object fails
                                obj1_passes_all_relpos = False
                                failure_reason = f"RelPos_NG: {obj1_type} failed '{pair_key}' - no partner in rel pos range."
                                if objects_failed_relpos_count == 0: first_relpos_failure_reason = failure_reason
                                break # Stop checking constraints for this object

                # Add object to final list if it passed all applicable relative position checks
                if obj1_passes_all_relpos:
                    final_classification[obj1_type].append(obj1_info)
                else:
                    objects_failed_relpos_count += 1

            num_passed_all = sum(len(v) for v in final_classification.values())
            print(f"[Checker][classify_masks] Relative position filter applied. {objects_failed_relpos_count} removed, {num_passed_all} remain.")
            if num_passed_all == 0 and len(feature_passed_containment_list) > 0: # Check if masks existed before filter
                print("[Checker][classify_masks] No masks passed relative position filter.")
                if objects_failed_relpos_count > 0: print(f"  Reason: {first_relpos_failure_reason}")
                # Keep final_classification empty
        t1 = time.time()
        print(f"[TIME] Relative Position Filter: {t1 - t0:.4f}s")
        # --- End Relative Position Filtering ---

        total_classify_time = time.time() - stage_start_time
        print(f"[TIME] Total classify_masks duration: {total_classify_time:.4f}s")
        print(f"[Checker][classify_masks] Final classification counts after all filters: { {k: len(v) for k, v in final_classification.items()} }")
        return final_classification
    # --- END classify_masks METHOD ---

    def check_overlaps(self, classified: Dict[str, List[Dict]]) -> Tuple[bool, str]:
        """
        Detects forbidden pixel overlaps between pairs of objects based on overlap rules.

        Args:
            classified (Dict[str, List[Dict]]): Dictionary of objects that passed
                                                all previous filtering steps.

        Returns:
            Tuple[bool, str]: (True, reason) if no forbidden overlaps found,
                              (False, reason) if a forbidden overlap is detected.
        """
        if not self.overlap_rules: return True, "No overlap rules defined"

        # Iterate through each overlap rule defined in the configuration
        for rule in self.overlap_rules:
            obj_types = rule.get("objects") # List of two object types (e.g., ["bezel", "copper_mark"])
            mode = rule.get("mode", "absolute").lower() # "absolute" or "ratio"
            threshold = rule.get("threshold", 0.0) # Used only for "ratio" mode

            # Validate rule format
            if not obj_types or len(obj_types) != 2:
                print(f"[Warning] Invalid 'objects' list in overlap rule: {rule}. Skipping.")
                continue

            obj1_type, obj2_type = obj_types[0], obj_types[1]
            # Get the lists of classified objects for these types
            obj1_list = classified.get(obj1_type, [])
            obj2_list = classified.get(obj2_type, [])

            # No need to check if one or both types have no objects
            if not obj1_list or not obj2_list: continue

            # Compare each object of type 1 with each object of type 2
            for o1_idx, o1 in enumerate(obj1_list):
                # If checking overlaps within the same type, avoid self-comparison and duplicates
                start_idx = o1_idx + 1 if obj1_type == obj2_type else 0
                for o2_idx in range(start_idx, len(obj2_list)):
                    o2 = obj2_list[o2_idx]

                    mask1 = o1.get("mask"); mask2 = o2.get("mask")
                    if mask1 is None or mask2 is None:
                        print(f"[Warning] Missing mask for overlap check between {obj1_type} and {obj2_type}.")
                        continue # Skip if mask data is missing

                    # Ensure masks are boolean for bitwise operations
                    mask1_bool = mask1.astype(bool) if mask1.dtype != bool else mask1
                    mask2_bool = mask2.astype(bool) if mask2.dtype != bool else mask2

                    # Calculate intersection (pixels common to both masks)
                    intersection = np.sum(mask1_bool & mask2_bool)

                    # Apply rule based on mode
                    if mode == "absolute":
                        # Fail if *any* intersection exists
                        if intersection > 0:
                            reason = f"Overlap_NG: Absolute overlap detected between {obj1_type} and {obj2_type}"
                            return False, reason
                    elif mode == "ratio":
                        # Calculate union and ratio
                        union = np.sum(mask1_bool | mask2_bool)
                        overlap_ratio = intersection / union if union > 0 else 0.0
                        # Fail if ratio exceeds threshold
                        if overlap_ratio > threshold:
                            reason = f"Overlap_NG: Ratio between {obj1_type} & {obj2_type} ({overlap_ratio:.3f}) > threshold {threshold:.3f}"
                            return False, reason
                    else: # Default to absolute if mode is unrecognized
                        if intersection > 0:
                            reason = f"Overlap_NG: Absolute overlap detected between {obj1_type} and {obj2_type}"
                            return False, reason

        # If loop completes without finding forbidden overlaps
        return True, "No excessive overlaps detected"

    def evaluate(self,
                 masks: List[np.ndarray],
                 filter_shape: Tuple[int, int],
                 edge_threshold: int = 5,
                 # *** NEW PARAMETER ***
                 enable_mask_iou_filter: bool = True, # Default to enabled
                 iou_threshold: float = 0.9, # Mask IoU
                 enable_relative_position_check: bool = True,
                 relative_position_pairs_to_check: Optional[List[str]] = None,
                 enable_containment_check: bool = True,
                 containment_reference_type: str = "bezel",
                 containment_target_type: str = "stamped_mark",
                 enable_bbox_nms: bool = True, # BBox NMS
                 bbox_nms_iou_threshold: float = 0.5, # BBox NMS
                 bbox_nms_target_types: Optional[List[str]] = None # BBox NMS
                 ) -> Tuple[bool, str, Dict[str, List[Dict]]]:
        """
        Performs the complete evaluation process on a list of input masks.

        Steps:
        1. Calls `classify_masks` to perform all filtering (Edge, MaskIoU, Feature, BBoxNMS, Dist, Contain, RelPos).
        2. Performs a Count Check on the filtered results against `expected_evaluation_count`.
        3. Performs an Overlap Check on the filtered results based on `overlap_rules`.

        Args:
            masks (List[np.ndarray]): Raw masks from the segmenter.
            filter_shape (Tuple[int, int]): Image shape (height, width).
            edge_threshold (int): Pixel threshold for edge filter.
            enable_mask_iou_filter (bool): If True, applies the Mask IoU filter step.
            iou_threshold (float): IoU threshold for *mask* overlap filter.
            enable_relative_position_check (bool): Enable/disable relative position filter.
            relative_position_pairs_to_check (Optional[List[str]]): Specific pairs for rel pos check.
            enable_containment_check (bool): Enable/disable containment filter.
            containment_reference_type (str): Reference object type for containment.
            containment_target_type (str): Target object type for containment.
            enable_bbox_nms (bool): Enable/disable *bounding box* NMS filter.
            bbox_nms_iou_threshold (float): IoU threshold for *bounding box* NMS.
            bbox_nms_target_types (Optional[List[str]]): Object types to apply BBox NMS to.

        Returns:
            Tuple[bool, str, Dict[str, List[Dict]]]:
                - final_ok (bool): True if all checks passed, False otherwise.
                - final_reason (str): Explanation of the evaluation result or error.
                - final_classified_masks (Dict): Dictionary of masks that passed all checks.
        """
        eval_start_time = time.time()
        print("[Checker] Starting evaluation...")
        final_reason = "Evaluation not completed"
        # Initialize with expected structure based on rules
        final_classified_masks: Dict[str, List[Dict]] = {rule['type']: [] for rule in self.classification_rules} if self.classification_rules else {}

        # --- 1. Integrated Classification & Filtering ---
        t0_classify = time.time()
        try:
            # Call the method that performs steps 1-7 of the filtering workflow
            # *** Pass the new enable_mask_iou_filter flag ***
            final_classified_masks = self.classify_masks(
                masks, filter_shape, edge_threshold,
                enable_mask_iou_filter=enable_mask_iou_filter, # Pass flag
                iou_threshold=iou_threshold,
                enable_relative_position_check=enable_relative_position_check,
                relative_position_pairs_to_check=relative_position_pairs_to_check,
                enable_containment_check=enable_containment_check,
                containment_reference_type=containment_reference_type,
                containment_target_type=containment_target_type,
                enable_bbox_nms=enable_bbox_nms,
                bbox_nms_iou_threshold=bbox_nms_iou_threshold,
                bbox_nms_target_types=bbox_nms_target_types
            )
            num_final_classified = sum(len(v) for v in final_classified_masks.values())
            t1_classify = time.time()
            print(f"[TIME] Integrated Classification (classify_masks call): {t1_classify - t0_classify:.4f}s")

            # Check if any masks survived the filtering process
            if num_final_classified == 0 and len(masks) > 0: # Check len(masks) to ensure it wasn't empty initially
                final_reason = "Eval_NG: No masks passed the combined classification and filtering steps."
                print(f"[Checker] {final_reason}")
                eval_duration = time.time() - eval_start_time
                print(f"[TIME] Total evaluate duration (early exit): {eval_duration:.4f}s")
                return False, final_reason, final_classified_masks # Return early

            print(f"[Checker] Integrated classification/filtering complete ({num_final_classified} masks remain).")

        except Exception as e:
            # Catch errors specifically during the classify_masks call
            t1_classify = time.time()
            final_reason = f"Eval_NG: Unexpected error during integrated classification: {e}"
            print(f"[Checker] {final_reason}\n{traceback.format_exc()}")
            print(f"[TIME] Integrated Classification (Failed): {t1_classify - t0_classify:.4f}s")
            eval_duration = time.time() - eval_start_time
            print(f"[TIME] Total evaluate duration (error): {eval_duration:.4f}s")
            return False, final_reason, final_classified_masks # Return on error
        # --- End Integrated Classification ---

        # --- 2. Count Check ---
        # Compares the count of remaining objects per type against expected counts in config
        t0_count = time.time()
        print("[Checker] Performing count check...")
        count_ok = True
        count_reason_parts = []
        if not self.classification_rules:
            print("[Warning] No classification rules defined for count check.")
        else:
            for rule in self.classification_rules:
                obj_type = rule['type']
                expected_eval_count = rule['expected_count'] # From config
                found_count = len(final_classified_masks.get(obj_type, [])) # Count remaining
                if found_count != expected_eval_count:
                    count_ok = False
                    count_reason_parts.append(f"Count_NG(Cfg): Expected {expected_eval_count} '{obj_type}', found {found_count}")
        t1_count = time.time()
        print(f"[TIME] Count Check: {t1_count - t0_count:.4f}s")

        if not count_ok:
            final_reason = "Eval_NG: " + "; ".join(count_reason_parts)
            print(f"[Checker] {final_reason}")
            eval_duration = time.time() - eval_start_time
            print(f"[TIME] Total evaluate duration (count fail): {eval_duration:.4f}s")
            return False, final_reason, final_classified_masks # Return early if count fails
        print("[Checker] Count check passed.")
        # --- End Count Check ---

        # --- 3. Overlap Check ---
        # Checks for forbidden pixel overlaps based on rules in config
        t0_overlap = time.time()
        print("[Checker] Performing overlap check...")
        overlap_ok, overlap_reason = self.check_overlaps(final_classified_masks)
        t1_overlap = time.time()
        print(f"[TIME] Overlap Check: {t1_overlap - t0_overlap:.4f}s")

        if not overlap_ok:
            final_reason = f"Eval_NG: {overlap_reason}"
            print(f"[Checker] {final_reason}")
            eval_duration = time.time() - eval_start_time
            print(f"[TIME] Total evaluate duration (overlap fail): {eval_duration:.4f}s")
            return False, final_reason, final_classified_masks # Return early if overlap fails
        print(f"[Checker] Overlap check passed ({overlap_reason}).")
        # --- End Overlap Check ---

        # If all checks passed up to this point
        final_reason = "OK: All checks passed (Integrated Filters, Count, Overlap)"
        eval_duration = time.time() - eval_start_time
        print(f"[Checker] Evaluation Result: {final_reason}")
        print(f"[TIME] Total evaluate duration: {eval_duration:.4f}s")
        return True, final_reason, final_classified_masks
    # --- END evaluate METHOD ---

